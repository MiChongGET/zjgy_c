
#### 1、将数组作为参数进行传递
 

> 有两种传递方法，一种是function(int a[ ]); 另一种是function(int *a)

这两种两种方法在函数中对数组参数的修改都会影响到实参本身的值！

对于第一种，根据之前所学，形参是实参的一份拷贝，是局部变量。但是数组是个例外，因为数组的数据太多了，将其一一赋值既麻烦又浪费空间，所以数组作为参数传递给函数的只是数组首元素的地址，数据还是在内存里的，函数在需要用到后面元素时再按照这个地址和数组下标去内存查找。也就是说后面的元素根本没到函数里来。所以，这里也不能在test()函数内部用sizeof求数组的大小，必须在外面算好了再传进来。

对于第二种，则是传址调用，无需再说。

这里还有几点需要注意：

- [x] 1.在以上两个函数的形参前面加上const则表示整个数组只读，而不是只有首地址对应存储的数据只读。

- [x] 2.第二种形式不能用C++11中的for...auto来循环打印。

- [x] 3.数组的大小要用sizeof()来求，不能用.size()，因为.size()只有struct 或者union才能用， vector算是struct！

- [x] 4.如果在函数内部又声明一个int* tmp类型的变量，然后把p赋值给tmp, 通过tmp修改数数组也是一样，都会修改实参本身

```
int a[3] = {1, 2, 3};
    //算出数组的大小
    int size = sizeof(a) / sizeof(int);
```


#### 2、多个对象构造和析构

1对象初始化列表

1）对象初始化列表出现原因

1.必须这样做：

如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，

如果没有初始化列表，那么他将无法完成第一步，就会报错。

 

2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值

当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，

因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。

2）C++中提供初始化列表对成员变量进行初始化

语法规则


```
Constructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)

{

// 其他赋值操作

}
```


3）注意概念

初始化：被初始化的对象正在创建

赋值：被赋值的对象已经存在

 

4）注意：

数据成员顺序最好和初始化列表的顺序一样

初始化列表先于构造函数的函数体执行

```
 

/*

1 C++中提供了初始化列表对成员变量进行初始化

2 使用初始化列表出现原因：

1.必须这样做：

如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，

而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，

如果没有初始化列表，那么他将无法完成第一步，就会报错。

 

2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值

当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，

因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。

*/


//总结 构造和析构的调用顺序
#include <iostream>
using namespace std;

class ABC

{

public:

    ABC(int a, int b, int c)

    {
        this->a = a;

        this->b = b;

        this->c = c;

        printf("a:%d,b:%d,c:%d \n", a, b, c);

        printf("ABC construct ..\n");

    }

    ~ABC()

    {
        printf("a:%d,b:%d,c:%d \n", a, b, c);

        printf("~ABC() ..\n");
    }

protected:

private:

    int a;

    int b;

    int c;

};

class MyD

{
public:

    MyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)

        //MyD()

    {
        cout << "MyD()" << endl;
    }

    ~MyD()

    {
        cout << "~MyD()" << endl;
    }

protected:

private:

    ABC abc1; //c++编译器不知道如何构造abc1

    ABC abc2;

    const int m;

};

int run()

{
    MyD myD;

    return 0;

}

int main()

{
    run();

    system("pause");

    return 0;

}
```
